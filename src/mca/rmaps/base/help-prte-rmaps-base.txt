# -*- text -*-
#
# Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana
#                         University Research and Technology
#                         Corporation.  All rights reserved.
# Copyright (c) 2004-2005 The University of Tennessee and The University
#                         of Tennessee Research Foundation.  All rights
#                         reserved.
# Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
#                         University of Stuttgart.  All rights reserved.
# Copyright (c) 2004-2005 The Regents of the University of California.
#                         All rights reserved.
# Copyright (c) 2011-2020 Cisco Systems, Inc.  All rights reserved
# Copyright (c) 2011      Los Alamos National Security, LLC.
#                         All rights reserved.
# Copyright (c) 2014-2020 Intel, Inc.  All rights reserved.
# Copyright (c) 2021-2022 Nanook Consulting.  All rights reserved.
# $COPYRIGHT$
#
# Additional copyrights may follow
#
# $HEADER$
#
# This is the US/English general help file for PRRTE's prun.
#
[prte-rmaps-base:alloc-error]
There are not enough slots available in the system to satisfy the %d
slots that were requested by the application:

  %s

Either request fewer procs for your application, or make more slots
available for use.

A "slot" is the PRRTE term for an allocatable unit where we can
launch a process.  The number of slots available are defined by the
environment in which PRRTE processes are run:

  1. Hostfile, via "slots=N" clauses (N defaults to number of
     processor cores if not provided)
  2. The --host command line parameter, via a ":N" suffix on the
     hostname (N defaults to 1 if not provided)
  3. Resource manager (e.g., SLURM, PBS/Torque, LSF, etc.)
  4. If none of a hostfile, the --host command line parameter, or an
     RM is present, PRRTE defaults to the number of processor cores

In all the above cases, if you want PRRTE to default to the number
of hardware threads instead of the number of processor cores, use the
--use-hwthread-cpus option.

Alternatively, you can use the --map-by :OVERSUBSCRIBE option to ignore the
number of available slots when deciding the number of processes to
launch.
#
[prte-rmaps-base:not-all-mapped-alloc]
Some of the requested hosts are not included in the current allocation for the
application:
  %s
The requested hosts were:
  %s

Verify that you have mapped the allocated resources properly using the
--host or --hostfile specification.
[prte-rmaps-base:no-mapped-node]
There are no allocated resources for the application:
  %s
that match the requested mapping:
  %s: %s

Verify that you have mapped the allocated resources properly for the
indicated specification.
[prte-rmaps-base:nolocal-no-available-resources]
There are no available nodes allocated to this job. This could be because
no nodes were found or all the available nodes were already used.

Note that since the -nolocal option was given no processes can be
launched on the local node.
[prte-rmaps-base:no-available-resources]
No nodes are available for this job, either due to a failure to
allocate nodes to the job, or allocated nodes being marked
as unavailable (e.g., down, rebooting, or a process attempting
to be relocated to another node when none are available).
[prte-rmaps-base:all-available-resources-used]
All nodes which are allocated for this job are already filled.
#
[out-of-vpids]
The system has exhausted its available ranks - the application is attempting
to spawn too many daemons and will be aborted.

This may be resolved by increasing the number of available ranks by
re-configuring with the --enable-jumbo-apps option, and then
re-building the application.
#
[rmaps:too-many-procs]
Your job has requested a conflicting number of processes for the
application:

App: %s
number of procs:  %d

This is more processes than we can launch under the following
additional directives and conditions:

%s:   %d
%s:   %d

Please revise the conflict and try again.
#
[too-many-cpus-per-rank]
Your job has requested more cpus per process(rank) than there
are cpus in a package:

  Cpus/rank: %d
  #cpus/package: %d

Please correct one or both of these values and try again.
#
[failed-map]
Your job failed to map. Either no mapper was available, or none
of the available mappers was able to perform the requested
mapping operation. This can happen if you request a map type
(e.g., loadbalance) and the corresponding mapper was not built.

  Mapper result:    %s
  #procs mapped:    %d
  #nodes assigned:  %d

#
[unrecognized-policy]
The specified %s directive is not recognized:

  Directive: %s

Please check for a typo or ensure that the directive is a supported
one.
#
[oversubscribe-conflict]
Conflicting directives for the default oversubscription policy were
given stating that oversubscription was both allowed and not allowed.

Please check that only one policy is defined.
#
[rmaps:binding-target-not-found]
A request was made to bind to %s, but an appropriate target could not
be found on node %s.
#
[rmaps:binding-overload]
A request was made to bind to that would result in binding more
processes than cpus on a resource:

   Bind to:     %s
   Node:        %s
   #processes:  %d
   #cpus:       %d

You can override this protection by adding the "overload-allowed"
option to your binding directive.
#
[rmaps:no-topology]
A mapping directive was given that requires knowledge of
a remote node's topology. However, no topology info is
available for the following node:

  Node: %s

The job cannot be executed under this condition. Please either
remove the directive or investigate the lack of topology info.
#
[rmaps:no-available-cpus]
While computing bindings, we found no available cpus on
the following node:

  Node:  %s

Please check your allocation.
#
[rmaps:cpubind-not-supported]
A request was made to bind a process, but at least one node does NOT
support binding processes to cpus.

Node: %s

PRRTE uses the "hwloc" library to perform process and memory
binding. This error message means that hwloc has indicated that
processor binding support is not available on this machine.

On OS X, processor and memory binding is not available at all (i.e.,
the OS does not expose this functionality).

On Linux, lack of the functionality can mean that you are on a
platform where processor and memory affinity is not supported in Linux
itself, or that hwloc was built without NUMA and/or processor affinity
support. When building hwloc (which, depending on your PRRTE
installation, may be embedded in PRRTE itself), it is important to
have the libnuma header and library files available. Different linux
distributions package these files under different names; look for
packages with the word "numa" in them. You may also need a developer
version of the package (e.g., with "dev" or "devel" in the name) to
obtain the relevant header files.

If you are getting this message on a non-OS X, non-Linux platform,
then hwloc does not support processor / memory affinity on this
platform. If the OS/platform does actually support processor / memory
affinity, then you should contact the hwloc maintainers:
https://github.com/open-mpi/hwloc.
#
[rmaps:membind-not-supported]
WARNING: a request was made to bind a process. While the system
supports binding the process itself, at least one node does NOT
support binding memory to the process location.

  Node:  %s

PRRTE uses the "hwloc" library to perform process and memory
binding. This error message means that hwloc has indicated that
processor binding support is not available on this machine.

On OS X, processor and memory binding is not available at all (i.e.,
the OS does not expose this functionality).

On Linux, lack of the functionality can mean that you are on a
platform where processor and memory affinity is not supported in Linux
itself, or that hwloc was built without NUMA and/or processor affinity
support. When building hwloc (which, depending on your PRRTE
installation, may be embedded in PRRTE itself), it is important to
have the libnuma header and library files available. Different linux
distributions package these files under different names; look for
packages with the word "numa" in them. You may also need a developer
version of the package (e.g., with "dev" or "devel" in the name) to
obtain the relevant header files.

If you are getting this message on a non-OS X, non-Linux platform,
then hwloc does not support processor / memory affinity on this
platform. If the OS/platform does actually support processor / memory
affinity, then you should contact the hwloc maintainers:
https://github.com/open-mpi/hwloc.

This is a warning only; your job will continue, though performance may
be degraded.
#
[rmaps:membind-not-supported-fatal]
A request was made to bind a process. While the system
supports binding the process itself, at least one node does NOT
support binding memory to the process location.

  Node:  %s

PRRTE uses the "hwloc" library to perform process and memory
binding. This error message means that hwloc has indicated that
processor binding support is not available on this machine.

On OS X, processor and memory binding is not available at all (i.e.,
the OS does not expose this functionality).

On Linux, lack of the functionality can mean that you are on a
platform where processor and memory affinity is not supported in Linux
itself, or that hwloc was built without NUMA and/or processor affinity
support. When building hwloc (which, depending on your PRRTE
installation, may be embedded in PRRTE itself), it is important to
have the libnuma header and library files available. Different linux
distributions package these files under different names; look for
packages with the word "numa" in them. You may also need a developer
version of the package (e.g., with "dev" or "devel" in the name) to
obtain the relevant header files.

If you are getting this message on a non-OS X, non-Linux platform,
then hwloc does not support processor / memory affinity on this
platform. If the OS/platform does actually support processor / memory
affinity, then you should contact the hwloc maintainers:
https://github.com/open-mpi/hwloc.

The provided memory binding policy requires that PRRTE abort the
job at this time.
#
[rmaps:no-bindable-objects]
No bindable objects of the specified type were available
on at least one node:

  Node:    %s
  Target:  %s
#
[rmaps:unknown-binding-level]
Unknown binding level:

  Target:  %s
  Cache level:  %u
#
[prte-rmaps-base:missing-daemon]
While attempting to build a map of this job, a node
was detected to be missing a daemon:

  Node:  %s

This usually indicates a mismatch between what the
allocation provided for the node name versus what was
actually found on the node.
#
[prte-rmaps-base:no-objects]
No objects of the specified type were found on at least one node:

  Type: %s
  Node: %s

The map cannot be done as specified.
#
[topo-file]
A topology file was given for the compute nodes, but
we were unable to correctly process it. Common errors
include incorrectly specifying the path to the file,
or the file being generated in a way that is incompatible
with the version of hwloc being used by OMPI.

  File: %s

Please correct the problem and try again.
#
[deprecated]
The following command line options and corresponding MCA parameter have
been deprecated and replaced as follows:

  Command line options:
    Deprecated:  %s
    Replacement: %s

  Equivalent MCA parameter:
    Deprecated:  %s
    Replacement: %s

The deprecated forms *will* disappear in a future version of PRRTE.
Please update to the new syntax.
#
[mismatch-binding]
A request for multiple cpus-per-proc was given, but a conflicting binding
policy was specified:

  #cpus-per-proc:  %d
  type of cpus:    %s
  binding policy given: %s

The correct binding policy for the given type of cpu is:

  correct binding policy:  %s

This is the binding policy we would apply by default for this
situation, so no binding need be specified. Please correct the
situation and try again.
#
[mapping-too-low]
A request for multiple cpus-per-proc was given, but a directive
was also given to map to an object level that has less cpus than
requested ones:

  #cpus-per-proc:  %d
  number of cpus:  %d
  map-by:          %s

Please specify a mapping level that has more cpus, or else let us
define a default mapping that will allow multiple cpus-per-proc.
#
[unrecognized-modifier]
The mapping request contains an unrecognized qualifier:

  Request: %s

Please check your request and try again. Remember, multiple
qualifiers must be separated by a colon (':').
#
[invalid-pattern]
The mapping request contains a pattern that doesn't match
the required syntax of #:object

  Pattern: %s

Please check your request and try again.
#
[prte-rmaps-base:oversubscribed]
The requested number of processes exceeds the allocated
number of slots:

  #slots:       %d
  #processes:   %d

This creates an oversubscribed condition that may adversely
impact performance when combined with the requested binding
operation. We will continue, but will not bind the processes.
This warning can be omitted by adding the "overload-allowed"
qualifier to the binding policy.
#
[cannot-launch]
Although we were able to map your job, we are unable to launch
it at this time due to required resources being busy. Please
try again later.
#
[rmaps:no-locale]
The request to bind processes could not be completed due to
an internal error - the locale of the following process was
not set by the mapper code:

  Process:  %s

Please contact the OMPI developers for assistance. Meantime,
you will still be able to run your application without binding
by specifying "--bind-to none" on your command line.
#
[mapping-too-low-init]
A request for multiple cpus-per-proc was given, but a directive
was also given to map to an object level that cannot support that
directive.

Please specify a mapping level that has more than one cpu, or
else let us define a default mapping that will allow multiple
cpus-per-proc.
#
[device-not-specified]
The request to map processes by distance could not be completed
because device to map near by was not specified. Please, use
rmaps_dist_device mca parameter to set it.
#
[num-procs-not-specified]
Either the -host or -hostfile options were given, but the number
of processes to start was omitted. This combination is not supported.

Please specify the number of processes to run and try again.
#
[failed-assignments]
The attempt to assign hardware locations to processes on a
compute node failed:

  Node:    %s
  Policy:  %s

We cannot continue - please check that the policy is in
accordance with the actual available hardware.
#
[rmaps:insufficient-cpus]
The request to bind processes to cpus in a provided list
of logical id's based on their local rank on a node cannot
be met due to there being more processes on a node than
available cpus:

  Node:         %s
  Local rank:   %d
  Cpu list:     %s

Please adjust either the number of processes per node or
the list of cpus.
#
[unsupported-default-modifier]
A %s modifier was provided that is not supported as a default value:

  Modifier:  %s

You can provide this modifier on a per-job basis, but it cannot
be the default setting.
#
[unsupported-default-policy]
A %s policy was provided that is not supported as a default value:

  Policy:  %s

You can provide this policy on a per-job basis, but it cannot
be the default setting.
#
[missing-value]
A %s was given that requires a value, but no value for it was given
or the value is missing the required '=' sign:

  Policy:  %s
  Given:   %s

Please provide a value for this policy, or remove it.
#
[insufficient-cpus]
An insufficient number of CPUs was found while attempting to map the job
using the given request:

  Mapping policy:  %s
  Default cpuset:  %s
  CPU list:        %s
  Available CPUs:  %s

Please modify either the external limit set by the resource manager (e.g.,
cgroup), the default cpuset specified, or the cpu list provided as the
mapping policy modifier.
#
[insufficient-cpus-per-proc]
A request was made to bind a given number of cpus to each process, but
not enough cpus are available to meet the request:

  Binding policy:  %s
  Node:            %s
  CPU envelope:    %s
  CPUs per proc:   %d

Please adjust your request and try again.
[invalid-value]
A %s was given that requires a value, but the provided value is invalid:

  Policy:  %s
  Given:   %s

Please provide a valid value for this policy, or remove it.
#
[rankfile-no-filename]
The request to map processes using a rankfile could not be completed
because the filename of the rankfile was not specified. Please 
specify the name of the rankfile.
#
[missing-modifier]
A ':' was found in a modifier specification but there is no modifier
following the ':'. Please specify a modifier.
#
[invalid-combination]
We cannot bind to hardware threads if we are not treating hardware
threads as independent CPUs since the lowest allocatable unit is
"core" by default. In order to bind to hardware threads, you must
therefore specify that we treat hardware threads as independent CPUs
by adding the "HWTCPUS" modifier to the "--map-by" directive.

The combination "--map-by core:hwtcpus --bind-to hwthread" or
"--map-by :hwtcpus --bind-to hwthread" will result in one process
being placed on each core, with the process bound to the first
hardware thread in that core.

In contrast, a case such as "--map-by package:hwtcpus --bind-to hwthread"
would result in each process being bound to successive hardware threads
on each package.
#
[unrecognized-qualifier]
The %s directive contains an unrecognized qualifier:

  Qualifier: %s
  Valid qualifiers: %s

Please check for a typo or ensure that the qualifier is a supported one.
#
[unrecognized-directive]
The specified %s directive is not recognized:

  Directive: %s
  Valid directives: %s

Please check for a typo or ensure that the directive is a supported one.
#
[missing-qualifier]
The %s option contains a directive that is missing a value:

  Directive: %s
  Valid directive: "%s=<value>"

Please check for a typo or ensure that the value is provided.
#
[missing-personality]
PRRTE has hit an internal problem that should never happen - it is
attempting to map a job that lacks an assigned personality.

  Job: %s

Please report this to the PRRTE developers (https://github.com/openpmix/prrte/issues)
#
[unsupported-combination]
A %s policy was provided that is not supported in combination
with the "PE=N" option:

  Policy:  %s

When specifying the number of CPUs to use for each process in a job,
the processes must be bound at the CPU level - either HWThread if
"HWTCPUS" was specified, or CORE. Please remove the bind policy
specification and try again.
#
[unsupported-mapping-combo]
A mapping policy was provided that is not supported in combination
with the "PE-LIST=x,y,z" option:

  Policy:  %s

When specifying the CPUs to be used for the job, the mapper can
only look at those CPUs. It is therefore not possible to map
the job according to some other target object. Please either
remove the mapping policy or change it to "slot" and try again.
#
#  MAP-BY-OPTION
#
[map-by-option]
Processes are mapped in a round-robin fashion based on
one of the following directives as applied at the job level:

-   SLOT assigns procs to each node up to the number of available
    slots on that node before moving to the next node in the
    allocation

-   HWTHREAD assigns a proc to each hardware thread on a node in a
    round-robin manner up to the number of available slots on that
    node before moving to the next node in the allocation

-   CORE (default) assigns a proc to each core on a node in a
    round-robin manner up to the number of available slots on that
    node before moving to the next node in the allocation

-   L1CACHE assigns a proc to each L1 cache on a node in a
    round-robin manner up to the number of available slots on that
    node before moving to the next node in the allocation

-   L2CACHE assigns a proc to each L2 cache on a node in a
    round-robin manner up to the number of available slots on that
    node before moving to the next node in the allocation

-   L3CACHE assigns a proc to each L3 cache on a node in a
    round-robin manner up to the number of available slots on that
    node before moving to the next node in the allocation

-   NUMA assigns a proc to each NUMA region on a node in a
    round-robin manner up to the number of available slots on that
    node before moving to the next node in the allocation

-   PACKAGE assigns a proc to each package on a node in a
    round-robin manner up to the number of available slots on that
    node before moving to the next node in the allocation

-   NODE assigns processes in a round-robin fashion to all nodes
    in the allocation, with the number assigned to each node capped
    by the number of available slots on that node

-   SEQ (often accompanied by the file=<path> qualifier) assigns
    one process to each node specified in the file. The sequential
    file is to contain an entry for each desired process, one per
    line of the file.

-   PPR:N:resource maps N procs to each instance of the specified
    resource type in the allocation

-   RANKFILE (often accompanied by the file=<path> qualifier) assigns
    one process to the node/resource specified in each entry of the
    file, one per line of the file.

-   PE-LIST=a,b assigns procs to each node in the allocation based on
    the ORDERED qualifier. The list is comprised of comma-delimited
    ranges of CPUs to use for this job. If the ORDERED qualifier is not
    provided, then each node will be assigned procs up to the number of
    available slots, capped by the availability of the specified CPUs.
    If ORDERED is given, then one proc will be assigned to each of the
    specified CPUs, if available, capped by the number of slots on each
    node and the total number of specified processes. Providing the
    OVERLOAD qualifier to the "bind-to" option removes the check on
    availability of the CPU in both cases.

Any directive can include qualifiers by adding a colon (:) and any
combination of one or more of the following (delimited by colons)
to the --map-by option (except where noted):

-   PE=n bind n CPUs to each process (can not be used in combination
    with rankfile or pe-list directives)

-   SPAN load balance the processes across the allocation by treating
    the allocation as a single "super-node" (can not be used in
    combination with slot, node, seq, ppr, rankfile, or
    pe-list directives)

-   OVERSUBSCRIBE allow more processes on a node than processing elements
-   NOOVERSUBSCRIBE means !OVERSUBSCRIBE

-   NOLOCAL do not launch processes on the same node as prun

-   HWTCPUS use hardware threads as CPU slots

-   CORECPUS use cores as CPU slots (default)

-   INHERIT
-   NOINHERIT means !INHERIT

-   FILE=<path> (path to file containing sequential or rankfile entries).

-   ORDERED only applies to the PE-LIST option to indicate that procs
    are to be bound to each of the specified CPUs in the order
    in which they are assigned (i.e., the first proc on a node shall
    be bound to the first CPU in the list, the second proc shall be
    bound to the second CPU, etc.)

Note that directives and qualifiers are case-insensitive
and can be shortened to the minimum number of characters
to uniquely identify them. Thus, "L1CACHE" can be given
as "l1cache" or simply as "L1".

The type of CPU (core vs hwthread) used in the mapping algorithm
is determined as follows:

* by user directive on the command line via the HWTCPUS qualifier to
  the "--map-by" directive

* by setting the "rmaps_default_mapping_policy" MCA parameter to
  include the "HWTCPUS" qualifier. This parameter sets the default
  value for a PRRTE DVM - qualifiers are carried across to DVM jobs
  started via "prun" unless overridden by the user's cmd line

* defaults to CORE in topologies where core CPUs are defined, and to
  hwthreads otherwise.

If your application uses threads, then you probably want to ensure that
you are either not bound at all (by specifying `--bind-to none`), or
bound to multiple cores using an appropriate binding level or specific
number of processing elements per application process via the "PE=#"
qualifier to the "--map-by" cmd line directive.

A more detailed description of the mapping, ranking, and binding procedure
can be obtained via the "--help placement" option.
#
#  RANK-BY-OPTION
#
[rank-by-option]
PRRTE automatically ranks processes for each job starting from zero.
Regardless of the algorithm used, rank assignments span applications
in the same job - i.e., a cmd line of

  -n 3 app1 : -n 2 app2

will result in app1 having three processes ranked 0-2 and app2 having
two processes ranked 3-4.

By default, process ranks are assigned in accordance with the mapping
directive - e.g., jobs that are mapped by-node will have the process
ranks assigned round-robin on a per-node basis. However, users can override
the default by specifying any of the following directives using the
--rank-by command line option:

-   SLOT assigns ranks to each process on a node in the order in
    which the mapper assigned them. This is the default behavior,
    but is provided as an explicit option to allow users to override
    any alternative default specified in the environment. When mapping
    to a specific resource type, procs assigned to a given instance
    of that resource on a node will be ranked on a per-resource basis
    on that node before moving to the next node.

-   NODE assigns ranks round-robin on a per-node basis

-   FILL assigns ranks to procs mapped to a particular resource type
    on each node, filling all ranks on that resource before moving to
    the next resource on that node. For example, procs mapped by-L1cache
    would have all procs on the first L1cache ranked sequentially before
    moving to the second L1cache on the node. Once all procs on the
    node have been ranked, ranking would continue on the next node.

-   SPAN assigns ranks round-robin to procs mapped to a particular
    resource type, treating the collection of resource instances
    spanning the entire allocation as a single "super node" before
    looping around for the next pass. Thus, ranking would begin with
    the first proc on the first L1cache on the first node, then the
    next rank would be assiged to the first proc on the second L1cache
    on that node, proceeding across until the first proc had been
    ranked on all L1caches used by the job before circling around to
    rank the second proc on each object.

The rank-by command line option has no qualifiers. Note that directives
are case-insensitive.

A more detailed description of the mapping, ranking, and binding procedure
can be obtained via the "--help placement" option.
#
[must-map-by-obj]
When ranking by FILL or by SPAN, you must map by an object
type (e.g., HWTHREAD, NUMA, or cache level):

  Map policy:   %s
  Rank policy:  %s

Please specify a supported combination and try again.
#
[out-of-resource]
Either there are not enough slots available in the system to launch
the %d processes that were requested by the application, or there are
not enough CPUs to bind them as requested:

  App: %s
  Mapping: %s
  Binding: %s

Either request fewer processes for your application, make more slots
available for use by expanding the allocation, or do not bind the
processes so that the number of CPUs is no longer a limiting factor.

A "slot" is the PRRTE term for an allocatable unit where we can
launch a process.  The number of slots available are defined by the
environment in which PRRTE processes are run:

  1. Hostfile, via "slots=N" clauses (N defaults to number of
     processor cores if not provided)
  2. The --host command line parameter, via a ":N" suffix on the
     hostname (N defaults to 1 if not provided)
  3. Resource manager (e.g., SLURM, PBS/Torque, LSF, etc.)
  4. If none of a hostfile, the --host command line parameter, or an
     RM is present, PRRTE defaults to the number of processor cores

In all the above cases, if you want PRRTE to default to the number
of hardware threads instead of the number of processor cores, use the
--use-hwthread-cpus option.

Alternatively, you can use the --map-by :OVERSUBSCRIBE option to ignore the
number of available slots when deciding the number of processes to
launch. Similarly, you can use the --bind-to :OVERLOAD option to bind
more than one process to a CPU, if desired, or --bind-to NONE to avoid
binding altogether.
#
#  PLACEMENT
#
[placement]
PRRTE provides a set of three controls for assigning process
locations and ranks:

  1. mapping:   Assigns a default location to each process
  2. ranking:   Assigns a unique rank value to each process
  3. binding:   Constrains each process to run on specific processors

This help entry provides an overview of these three controls. Unless
otherwise noted, this behavior is shared by prun (working with a PRRTE
DVM), and prterun. More detail about PRRTE process placement is available
in the following sections (using `--help placement-<section>`):

* examples - some examples of the interactions between mapping, ranking,
             and binding options
* fundamentals - provides deeper insight into PRRTE's mapping, ranking,
                 and binding options
* limits - explains the difference between _overloading_ and _oversubscribing_
           resources
* diagnostics - describes options for obtaining various diagnostic reports
                that aid the user in verifying and tuning the placement
                for a specific job
* rankfiles - explains the format and use of the rankfile mapper for
              specifying arbitrary process placements
* deprecated - a list of deprecated options and their new equivalents
* all - outputs all the placement help except for the "deprecated" section


-- Quick Summary --
The two binaries that most influence process layout are `prte` and `prun`.
The `prte` process discovers the allocation, establishes a Distributed
Virtual Machine by starting a `prted` daemon on each node of the allocation,
and defines the efault mapping/ranking/binding policies for all jobs.
The `prun` process defines the specific mapping/ranking/binding for a specific
job. Most of the command line controls are targeted to `prun` since each job has
its own unique requirements.

`prterun` is just a wrapper around `prte` for a single job PRRTE DVM. It is
doing the job of both `prte` and `prun`, and, as such, accepts the sum all of
their command line arguments. Any example that uses `prun` can substitute the
use of `prterun` except where otherwise noted.

The `prte` process attempts to automatically discover the nodes in the
allocation by querying supported resource managers. If a supported resource
manager is not present then `prte` relies on a hostfile provided by the user.
In the absence of such a hostfile it will run all processes on the localhost.

If running under a supported resource manager, the `prte` process will start the
daemon processes (`prted`) on the remote nodes using the corresponding resource
manager process starter. If no such starter is available then `rsh` or `ssh`
is used.

Minus user direction, PRRTE will automatically map processes in a
round-robin fashion by CPU, binding each process to its own CPU. The
type of CPU used (core vs hwthread) is determined by (in priority order):

* user directive on the command line via the HWTCPUS qualifier to
  the "--map-by" directive

* setting the "rmaps_default_mapping_policy" MCA parameter to
  include the "HWTCPUS" qualifier. This parameter sets the default
  value for a PRRTE DVM - qualifiers are carried across to DVM jobs
  started via "prun" unless overridden by the user's cmd line

* defaulting to CORE in topologies where core CPUs are defined, and to
  hwthreads otherwise.

By default, the ranking algorithm will follow the mapping pattern. Thus,
mapping by-node will default to ranking by-node.

PRRTE automatically binds processes unless directed not to do so by the
user. Minus direction, PRRTE will bind individual processes to their
own core within the object to which they were mapped. Should a node become
oversubscribed during the mapping process, and if oversubscription is
allowed, all subsequent processes assigned to that node will _not_ be bound.
#
#  EXAMPLES
#
[placement-examples]
-------------------------------- Examples ----------------------------------

Listed here are the subset of command line options that will be used in the
process mapping/ranking/binding examples below.

** Specifying Host Nodes

Use one of the following options to specify which hosts (nodes) within
the PRRTE DVM environment to run on.

`--host <host1,host2,...,hostN>` or `--host <host1:X,host2:Y,...,hostN:Z>`

:   List of hosts on which to invoke processes. After each hostname a
    colon (`:`) followed by a positive integer can be used to specify the
    number of slots on that host (`:X`, `:Y`, and `:Z`). The default is `1`.

`--hostfile <hostfile>`

:   Provide a hostfile to use.

** Process Mapping / Ranking / Binding Options

The following options specify the number of processes to launch. Note
that none of the options imply a particular binding policy - e.g.,
requesting `N` processes for each socket does not imply that the processes
will be bound to the socket.

`-c, -n, --n, --np <#>`

:   Run this many copies of the program on the given nodes. This option
    indicates that the specified file is an executable program and not
    an application context. If no value is provided for the number of
    copies to execute (i.e., neither the `-np` nor its synonyms are
    provided on the command line), `prun` will automatically execute a
    copy of the program on each process slot (see below for description
    of a "process slot"). This feature, however, can only be used in
    the SPMD model and will return an error (without beginning execution
    of the application) otherwise.

To map processes across sets of objects:

`--map-by <object>`

:   Map to the specified object. Supported options include `slot`, `hwthread`,
    `core` (default), `l1cache`, `l2cache`, `l3cache`, `numa`, `package`, `node`,
    `seq`, `ppr`, `rankfile`, and `pe-list`.

Any object can include qualifiers by adding a colon (`:`) and any colon-delimited
combination of one or more of the following to the `--map-by` option:

 - `PE=n` bind `n` processing elements to each process (can not be used in
    combination with rankfile or pe-list directives)
 - `SPAN` load balance the processes across the allocation (can not be used in
    combination with slot, node, seq, ppr, rankfile, or pe-list directives)
 - `OVERSUBSCRIBE` allow more processes on a node than processing elements
 - `NOOVERSUBSCRIBE` means `!OVERSUBSCRIBE`
 - `NOLOCAL` do not launch processes on the same node as `prun`
 - `HWTCPUS` use hardware threads as CPU slots
 - `CORECPUS` use cores as CPU slots (default)
 - `INHERIT`
 - `NOINHERIT` means `!INHERIT`
 - `FILE=<path>` (path to file containing sequential or rankfile entries).
 -  ORDERED only applies to the PE-LIST option to indicate that procs
    are to be bound to each of the specified CPUs in the order
    in which they are assigned (i.e., the first proc on a node shall
    be bound to the first CPU in the list, the second proc shall be
    bound to the second CPU, etc.)

`ppr` policy example: `--map-by ppr:N:<object>` will launch `N` times the
number of objects of the specified type on each node.

Note that directives and qualifiers are case-insensitive and can be shortened
to the minimum number of characters to uniquely identify them. Thus, "L1CACHE"
can be given as "l1cache" or simply as "L1".

To order processes' ranks:

`--rank-by <object>`

:   Rank in round-robin fashion according to the specified object. The default
    follows the mapping pattern. Supported options include `slot`, `node`,
    `fill`, and `span`.

There are no qualifiers for the `--rank-by` directive.

To bind processes to sets of objects:

`--bind-to <object>`

:   Bind processes to the specified object. See defaults in Quick Summary.
    Supported options include `none`, `hwthread`, `core`, `l1cache`,
    `l2cache`, `l3cache`, `numa`, and `package`.

Any object can include qualifiers by adding a colon (`:`) and any colon-delimited
combination of one or more of the following to the `--bind-to` option:

 - `overload-allowed` allows for binding more than one process in relation to a CPU
 - `if-supported` if binding to that object is supported on this system

** Examples: Specifying Host Nodes

Host nodes can be identified on the command line with the `--host` option or
in a hostfile.

For example, assuming no other resource manager or scheduler is involved,

`prun --host aa,aa,bb ./a.out`

:   launches two processes on node `aa` and one on `bb`.

`prun --host aa ./a.out`

:   launches one process on node `aa`.

`prun --host aa:5 ./a.out`

:   launches five processes on node `aa`.

Or, consider the hostfile

```
$ cat myhostfile
aa slots=2
bb slots=2
cc slots=2
```

Here, we list both the host names (`aa`, `bb`, and `cc`) but also how
many "slots" there are for each. Slots indicate how many processes can
potentially execute on a node. For best performance, the number of
slots may be chosen to be the number of cores on the node or the
number of processor sockets.

If the hostfile does not provide slots information, the PRRTE DVM will attempt
to discover the number of cores (or hwthreads, if the `:HWTCPUS` qualifier to
the `--map-by` option is set) and set the number of slots to that value.

Examples using the hostfile above with and without the `--host` option

`prun --hostfile myhostfile ./a.out`

:   will launch two processes on each of the three nodes.

`prun --hostfile myhostfile --host aa ./a.out`

:   will launch two processes, both on node `aa`.

`prun --hostfile myhostfile --host dd ./a.out`

:   will find no hosts to run on and abort with an error. That is, the
    specified host `dd` is not in the specified hostfile.

When running under resource managers (e.g., SLURM, Torque, etc.), PRTE will
obtain both the hostnames and the number of slots directly from the resource
manger. The behavior of `--host` in that environment will behave the same as
if a hostfile was provided (since it is provided by the resource manager).


**  Examples: Specifying Number of Processes

As we have just seen, the number of processes to run can be set using
the hostfile. Other mechanisms exist.

The number of processes launched can be specified as a multiple of the
number of nodes or processor sockets available. Consider the hostfile below for
the examples that follow.

```
$ cat myhostfile
aa
bb
```

For example,

`prun --hostfile myhostfile --map-by ppr:2:package ./a.out`

:   launches processes 0-3 on node `aa` and process 4-7 on node `bb`, where
    `aa` and `bb` are both dual-package nodes. The `--map-by ppr:2:package`
    option also turns on the `--bind-to package` option, which is discussed
    in a later section.

`prun --hostfile myhostfile --map-by ppr:2:node ./a.out`

:   launches processes 0-1 on node `aa` and processes 2-3 on node `bb`.

`prun --hostfile myhostfile --map-by ppr:1:node ./a.out`

:   launches one process per host node.

Another alternative is to specify the number of processes with the `--np`
option. Consider now the hostfile

```
$ cat myhostfile
aa slots=4
bb slots=4
cc slots=4
```

Now,

`prun --hostfile myhostfile --np 6 ./a.out`

:   will launch processes 0-3 on node `aa` and processes 4-5 on node `bb`.
    The remaining slots in the hostfile will not be used since the `-np`
    option indicated that only 6 processes should be launched.


-- Examples: Mapping Processes to Nodes Using Policies --

The examples above illustrate the default mapping of process processes
to nodes. This mapping can also be controlled with various `prun`/`prterun`
options that describe mapping policies.

```
$ cat myhostfile
aa slots=4
bb slots=4
cc slots=4
```

Consider the hostfile above, with `--np 6`:

```
                              node aa      node bb      node cc
prun                          0 1 2 3      4 5
prun --map-by node            0 3          1 4          2 5
prun --map-by node:NOLOCAL                 0 2 4        1 3 5
```

The `--map-by node` option will load balance the processes across the
available nodes, numbering each process by node in a round-robin fashion.

The `:NOLOCAL` qualifier to `--map-by` prevents any processes from being mapped
onto the local host (in this case node `aa`). While `prun` typically consumes
few system resources, the `:NOLOCAL` qualifier can be helpful for launching
very large jobs where `prun` may actually need to use noticeable amounts of
memory and/or processing time.

Just as `--np` can specify fewer processes than there are slots, it can
also oversubscribe the slots. For example, with the same hostfile:

`prun --hostfile myhostfile --np 14 ./a.out`

:   will produce an error since the default `:NOOVERSUBSCRIBE` qualifier to
    `--map-by` prevents oversubscription.

To oversubscribe the nodes you can use the `:OVERSUBSCRIBE` qualifier to
`--map-by`:

`prun --hostfile myhostfile --np 14 --map-by :OVERSUBSCRIBE ./a.out`

:   will launch processes 0-5 on node `aa`, 6-9 on `bb`, and 10-13 on `cc`.

Limits to oversubscription can also be specified in the hostfile itself
with the `max_slots` field:
```
$ cat myhostfile
aa slots=4 max_slots=4
bb         max_slots=8
cc slots=4
```

The `max_slots` field specifies such a limit. When it does, the `slots`
value defaults to the limit. Now:

`prun --hostfile myhostfile --np 14 --map-by :OVERSUBSCRIBE ./a.out`

:   causes the first 12 processes to be launched as before, but the
    remaining two processes will be forced onto node cc. The other two
    nodes are protected by the hostfile against oversubscription by this
    job.

Using the `:NOOVERSUBSCRIBE` qualifier to `--map-by` option can be helpful
since the PRTE DVM currently does not get "max_slots" values from the
resource manager.


Of course, `--np` can also be used with the `--host` option. For
example,

`prun --host aa,bb --np 8 ./a.out`

:   will produce an error since the default `:NOOVERSUBSCRIBE` qualifier to
    `--map-by` prevents oversubscription.

`prun --host aa,bb --np 8 --map-by :OVERSUBSCRIBE ./a.out`

:   launches 8 processes. Since only two hosts are specified, after the
    first two processes are mapped, one to `aa` and one to `bb`, the
    remaining processes oversubscribe the specified hosts evenly.

`prun --host aa:2,bb:6 --np 8 ./a.out`

:   launches 8 processes. Processes 0-1 on node `aa` since it has 2 slots and
    processes 2-7 on node `bb` since it has 6 slots.

And here is a MIMD example:

`prun --host aa --np 1 hostname : --host bb,cc --np 2 uptime`

:   will launch process 0 running `hostname` on node `aa` and processes 1
    and 2 each running `uptime` on nodes `bb` and `cc`, respectively.

#
#  FUNDAMENTALS
#
[placement-fundamentals]
--------------- Mapping, Ranking, and Binding Fundamentals -------------------

The mapping of processes to nodes can be defined not just with
general policies but also, if necessary, using arbitrary mappings that
cannot be described by a simple policy. Supported directives, given on
the cmd line via the `--map-by` option, include:

-   SEQ (often accompanied by the file=<path> qualifier) assigns
    one process to each node specified in the file. The sequential
    file is to contain an entry for each desired process, one per
    line of the file.

-   RANKFILE (often accompanied by the file=<path> qualifier) assigns
    one process to the node/resource specified in each entry of the
    file, one per line of the file.

For example, using the hostfile below:
```
$ cat myhostfile
aa slots=4
bb slots=4
cc slots=4
```

The command below will launch three processes, one on each of nodes `aa`, `bb`,
and `cc`, respectively. The slot counts don't matter; one process is launched
per line on whatever node is listed on the line.
```
$ prun --hostfile myhostfile --map-by seq ./a.out
```

Impact of the ranking option is best illustrated by considering the following
hostfile and test cases where each node contains two packages (each package with
two cores). Using the `--map-by ppr:2:package` option, we map two processes onto
each package and utilize the `--rank-by` option as show below:

```
$ cat myhostfile
aa
bb
```

```
                         node aa       node bb
--rank-by core           0 1 ! 2 3     4 5 ! 6 7
--rank-by package        0 2 ! 1 3     4 6 ! 5 7
--rank-by package:SPAN   0 4 ! 1 5     2 6 ! 3 7
```

Ranking by slot provides the identical result as ranking by core in this
case - a simple progression of ranks across each node. Ranking by package
does a round-robin ranking across packages within each node until all
processes have been assigned a rank, and then progresses to the next node.
Adding the `:SPAN` qualifier to the ranking directive causes the ranking
algorithm to treat the entire allocation as a single entity - thus, the
process ranks are assigned across all packages before circling back around
to the beginning.

The binding operation restricts the process to a subset of the CPU resources
on the node.

The processors to be used for binding can be identified in terms of
topological groupings - e.g., binding to an l3cache will bind each
process to all processors within the scope of a single L3 cache within
their assigned location. Thus, if a process is assigned by the mapper to
a certain package, then a `--bind-to l3cache` directive will cause the
process to be bound to the processors that share a single L3 cache
within that package.

To help balance loads, the binding directive uses a round-robin method,
binding a process to the first available specified object type within
the object where the process was mapped. For example, consider the case
where a job is mapped to the package level, and then bound to core. Each
package will have multiple cores, so if multiple processes are mapped to
a given package, the binding algorithm will assign each process located
to a package to a unique core in a round-robin manner.

Binding can only be done to the mapped object or to a resource located
within that object.

An object is considered completely consumed when the number of
processes bound to it equals the number of CPUs within it. Unbound
processes are not considered in this computation. Additional
processes cannot be mapped to consumed objects unless the
OVERLOAD qualifier is provided via the "--bind-to" command
line option.

Default process mapping/ranking/binding policies can also be set with MCA
parameters, overridden by the command line options when provided. MCA
parameters can be set on the `prte` command line when starting the
DVM (or in the `prterun` command line for a single-execution job), but
also in a system or user `mca-params.conf` file or as environment
variables, as described in the MCA section below. Some examples include:

```
prun option              MCA parameter key          value
--map-by core        rmaps_default_mapping_policy   core
--map-by package     rmaps_default_mapping_policy   package
--rank-by core       rmaps_default_ranking_policy   core
--bind-to core       hwloc_default_binding_policy   core
--bind-to package    hwloc_default_binding_policy   package
--bind-to none       hwloc_default_binding_policy   none
```
#
#  LIMITS
#
[placement-limits]
-----------  Difference between overloading and oversubscription  -----------

This section explores the difference between these two options. Users are often
confused by the difference between these two scenarios. As such this section
provides a number of scenarios to help illustrate the differences.

 - `--map-by :OVERSUBSCRIBE` allow more processes on a node than allocated slots
 - `--bind-to <object>:overload-allowed` allows for binding more than one process
    in relation to a CPU

The important thing to remember with _oversubscribing_ is that it can be
defined separately from the actual number of CPUs on a node. This allows the
mapper to place more or fewer processes per node than CPUs. By default, PRRTE
uses cores to determine slots in the absence of such information provided in
the hostfile or by the resource manager (except in the case of the `--host`
as described in the "Specifying Host Nodes" section).

The important thing to remember with _overloading_ is that it is defined as
binding more processes than CPUs. By default, PRRTE uses cores as a means of
counting the number of CPUs. However, the user can adjust this. For example
when using the `:HWTCPUS` qualifier to the `--map-by` option PRRTE will use
hardware threads as a means of counting the number of CPUs.

For the following examples consider a node with:
 - Two processor packages,
 - Ten cores per package, and
 - Eight hardware threads per core.

Consider the node from above with the hostfile below:

```
$ cat myhostfile
node01 slots=32
node02 slots=32
```

The "slots" tells PRRTE that it can place up to 32 processes before
_oversubscribing_ the node.

If we run the following:
```
prun --np 34 --hostfile myhostfile --map-by core --bind-to core hostname
```

It will return an error at the binding time indicating an _overloading_ scenario.

The mapping mechanism assigns 32 processes to `node01` matching the "slots"
specification in the hostfile. The binding mechanism will bind the first 20
processes to unique cores leaving it with 12 processes that it cannot bind
without overloading one of the cores (putting more than one process on the
core).

Using the `overload-allowed` qualifier to the `--bind-to core` option tells
PRRTE that it may assign more than one process to a core.

If we run the following:
```
prun --np 34 --hostfile myhostfile --map-by core --bind-to core:overload-allowed hostname
```

This will run correctly placing 32 processes on `node01`, and 2 processes on
`node02`. On `node01` two processes are bound to cores 0-11 accounting for
the overloading of those cores.

Alternatively, we could use hardware threads to give binding a lower level
CPU to bind to without overloading.

If we run the following:
```
prun --np 34 --hostfile myhostfile --map-by core:HWTCPUS --bind-to hwthread hostname
```

This will run correctly placing 32 processes on `node01`, and 2 processes on
`node02`. On `node01` two processes are mapped to cores 0-11 but bound to
different hardware threads on those cores (the logical first and second
hardware thread). Thus no hardware threads are overloaded at binding time.

In both of the examples above the node is not oversubscribed at mapping time
because the hostfile set the oversubscription limit to "slots=32" for each
node. It is only after we exceed that limit that PRRTE will throw an
oversubscription error.

Consider next if we ran the following:
```
prun --np 66 --hostfile myhostfile --map-by core:HWTCPUS --bind-to hwthread hostname
```

This will return an error at mapping time indicating an oversubscription
scenario. The mapping mechanism will assign all of the available slots
(64 across 2 nodes) and be left two processes to map. The only way to map
those processes is to exceed the number of available slots putting the job
into an oversubscription scenario.

You can force PRRTE to oversubscribe the nodes by using the `:OVERSUBSCRIBE`
qualifier to the `--map-by` option as seen in the example below:
```
prun --np 66 --hostfile myhostfile --map-by core:HWTCPUS:OVERSUBSCRIBE --bind-to hwthread hostname
```

This will run correctly placing 34 processes on `node01` and 32 on `node02`.
Each process is bound to a unique hardware thread.

** Overloading vs Oversubscription: Package Example

Let's extend these examples by considering the package level.
Consider the same node as before, but with the hostfile below:
```
$ cat myhostfile
node01 slots=22
node02 slots=22
```

The lowest level CPUs are 'cores' and we have 20 total (10 per package).

If we run:
```
prun --np 20 --hostfile myhostfile --map-by package --bind-to package:REPORT hostname
```

Then 10 processes are mapped to each package, and bound at the package level.
This is not overloading since we have 10 CPUs (cores) available in the package
at the hardware level.

However, if we run:
```
prun --np 21 --hostfile myhostfile --map-by package --bind-to package:REPORT hostname
```

Then 11 processes are mapped to the first package and 10 to the second package.
At binding time we have an overloading scenario because there are only
10 CPUs (cores) available in the package at the hardware level. So the first
package is overloaded.

** Overloading vs Oversubscription: Hardware Threads Example

Similarly, if we consider hardware threads.

Consider the same node as before, but with the hostfile below:
```
$ cat myhostfile
node01 slots=165
node02 slots=165
```

The lowest level CPUs are 'hwthreads' (because we are going to use the
`:HWTCPUS` qualifier) and we have 160 total (80 per package).

If we re-run (from the package example) and add the `:HWTCPUS` qualifier:
```
prun --np 21 --hostfile myhostfile --map-by package:HWTCPUS --bind-to package:REPORT hostname
```

Without the `:HWTCPUS` qualifier this would be overloading (as we saw
previously). The mapper places 11 processes on the first package and 10 to the
second package. The processes are still bound to the package level. However,
with the `:HWTCPUS` qualifier, it is not overloading since we have
80 CPUs (hwthreads) available in the package at the hardware level.

Alternatively, if we run:
```
prun --np 161 --hostfile myhostfile --map-by package:HWTCPUS --bind-to package:REPORT hostname
```

Then 81 processes are mapped to the first package and 80 to the second package.
At binding time we have an overloading scenario because there are only
80 CPUs (hwthreads) available in the package at the hardware level.
So the first package is overloaded.

#
#  DIAGNOSTICS
#
[placement-diagnostics]
--------------------------------  Diagnostics  ----------------------------------------

PRRTE provides various diagnostic reports that aid the user in verifying and
tuning the mapping/ranking/binding for a specific job.

The `:REPORT` qualifier to the `--bind-to` command line option can be used to
report process bindings.

As an example, consider a node with:
 - Two processor packages,
 - Four cores per package, and
 - Eight hardware threads per core.

In each of the examples below the binding is reported in a human readable
format.

```
$ prun --np 4 --map-by core --bind-to core:REPORT ./a.out
[node01:103137] MCW rank 0 bound to package[0][core:0]
[node01:103137] MCW rank 1 bound to package[0][core:1]
[node01:103137] MCW rank 2 bound to package[0][core:2]
[node01:103137] MCW rank 3 bound to package[0][core:3]
```

In the example above, processes are bound to successive cores on the
first package.

```
$ prun --np 4 --map-by package --bind-to package:REPORT ./a.out
[node01:103115] MCW rank 0 bound to package[0][core:0-9]
[node01:103115] MCW rank 1 bound to package[1][core:10-19]
[node01:103115] MCW rank 2 bound to package[0][core:0-9]
[node01:103115] MCW rank 3 bound to package[1][core:10-19]
```

In the example above, processes are bound to all cores on successive packages
in a round-robin fashion.

```
$ prun --np 4 --map-by package:PE=2 --bind-to core:REPORT ./a.out
[node01:103328] MCW rank 0 bound to package[0][core:0-1]
[node01:103328] MCW rank 1 bound to package[1][core:10-11]
[node01:103328] MCW rank 2 bound to package[0][core:2-3]
[node01:103328] MCW rank 3 bound to package[1][core:12-13]
```

The example above shows us that 2 cores have been bound per process.
The `:PE=2` qualifier states that 2 CPUs underneath the package
(which would be cores in this case) are mapped to each process.


```
$ prun --np 4 --map-by core:PE=2:HWTCPUS --bind-to :REPORT  hostname
[node01:103506] MCW rank 0 bound to package[0][hwt:0-1]
[node01:103506] MCW rank 1 bound to package[0][hwt:8-9]
[node01:103506] MCW rank 2 bound to package[0][hwt:16-17]
[node01:103506] MCW rank 3 bound to package[0][hwt:24-25]
```

The example above shows us that 2 hardware threads have been bound per process.
In this case `prun` is directing the DVM to map by hardware threads since we
used the `:HWTCPUS` qualifier. Without that qualifier this command would return
an error since by default the DVM will not map to resources smaller than a core.
The `:PE=2` qualifier states that 2 processing elements underneath the core
(which would be hardware threads in this case) are mapped to each process.


```
$ prun --np 4 --bind-to none:REPORT  hostname
[node01:107126] MCW rank 0 is not bound (or bound to all available processors)
[node01:107126] MCW rank 1 is not bound (or bound to all available processors)
[node01:107126] MCW rank 2 is not bound (or bound to all available processors)
[node01:107126] MCW rank 3 is not bound (or bound to all available processors)
```

Binding is turned off in the above example, as reported.
#
#  RANKFILES
#
[placement-rankfiles]
---------------------------------  Rankfiles  ------------------------------------

Another way to specify arbitrary mappings is with a rankfile, which gives you
detailed control over process binding as well.

Rankfiles are text files that specify detailed information about how individual
processes should be mapped to nodes, and to which processor(s) they should be
bound. Each line of a rankfile specifies the location of one process. The
general form of each line in the rankfile is:

```
rank <N>=<hostname> slot=<slot list>
```

For example:
```
$ cat myrankfile
rank 0=aa slot=10-12
rank 1=bb slot=0,1,4
rank 2=cc slot=1-2
$ prun --host aa,bb,cc,dd --map-by rankfile:FILE=myrankfile ./a.out
```

Means that

```
Rank 0 runs on node aa, bound to logical cores 10-12.
Rank 1 runs on node bb, bound to logical cores 0, 1, and 4.
Rank 2 runs on node cc, bound to logical cores 1 and 2.
```

Similarly:
```
$ cat myrankfile
rank 0=aa slot=1:0-2
rank 1=bb slot=0:0,1,4
rank 2=cc slot=1-2
$ prun --host aa,bb,cc,dd --map-by rankfile:FILE=myrankfile ./a.out
```

Means that

```
Rank 0 runs on node aa, bound to logical package 1, cores 10-12 (the 0th through
       2nd cores on that package).
Rank 1 runs on node bb, bound to logical package 0, cores 0, 1, and 4.
Rank 2 runs on node cc, bound to logical cores 1 and 2.
```

The hostnames listed above are "absolute," meaning that actual resolvable
hostnames are specified. However, hostnames can also be specified as
"relative," meaning that they are specified in relation to an
externally-specified list of hostnames (e.g., by `prun`'s `--host` argument,
a hostfile, or a job scheduler).

The "relative" specification is of the form "`+n<X>`", where `X` is an integer
specifying the Xth hostname in the set of all available hostnames, indexed
from 0. For example:

```
$ cat myrankfile
rank 0=+n0 slot=10-12
rank 1=+n1 slot=0,1,4
rank 2=+n2 slot=1-2
$ prun --host aa,bb,cc,dd --map-by rankfile:FILE=myrankfile ./a.out
```

All package/core slot locations are be specified as *logical* indexes. You can
use tools such as HWLOC's "lstopo" to find the logical indexes of packages and
cores.

#
#  DEPRECATED OPTIONS
#
[placement-deprecated]
------------------------------  Deprecated Options  ----------------------------

These deprecated options will be removed in a future release.

`--bind-to-core`

:   **(Deprecated: Use `--bind-to core`)**
    Bind processes to cores

`-bind-to-socket, --bind-to-socket`

:   **(Deprecated: Use `--bind-to package`)**
    Bind processes to processor sockets

`--bycore`

:   **(Deprecated: Use `--map-by core`)**
    Map processes by core

`-bynode, --bynode`

:   **(Deprecated: Use `--map-by node`)**
    Launch processes one per node, cycling by node in a round-robin
    fashion. This spreads processes evenly among nodes and assigns ranks
    in a round-robin, "by node" manner.

`--byslot`

:   **(Deprecated: Use `--map-by slot`)**
    Map and rank processes round-robin by slot.

`--cpus-per-proc <#perproc>`

:   **(Deprecated: Use `--map-by <obj>:PE=<#perproc>`)**
    Bind each process to the specified number of cpus.

`--cpus-per-rank <#perrank>`

:   **(Deprecated: Use `--map-by <obj>:PE=<#perrank>`)**
    Alias for `--cpus-per-proc`.

`--display-allocation`

:   **(Deprecated: Use `--display ALLOC`)**
    Display the detected resource allocation.

`--display-devel-map`

:   **(Deprecated: Use `--display MAP-DEVEL`)**
    Display a detailed process map (mostly intended for developers) just
    before launch.

`--display-map`

:   **(Deprecated: Use `--display MAP`)**
    Display a table showing the mapped location of each process prior to
    launch.

`--display-topo`

:   **(Deprecated: Use `--display TOPO`)**
    Display the topology as part of the process map (mostly intended for
    developers) just before launch.

`--do-not-launch`

:   **(Deprecated: Use `--map-by :DONOTLAUNCH`)**
    Perform all necessary operations to prepare to launch the application,
    but do not actually launch it (usually used to test mapping patterns).

`--do-not-resolve`

:   **(Deprecated: Use `--map-by :DONOTRESOLVE`)**
    Do not attempt to resolve interfaces - usually used to determine proposed
    process placement/binding prior to obtaining an allocation.

`-N <num>`

:   **(Deprecated: Use `--map-by prr:<num>:node`)**
    Launch `num` processes per node on all allocated nodes.

`--nolocal`

:   **(Deprecated: Use `--map-by :NOLOCAL`)**
    Do not run any copies of the launched application on the same node
    as `prun` is running. This option will override listing the `localhost`
    with `--host` or any other host-specifying mechanism.

`--nooversubscribe`

:   **(Deprecated: Use `--map-by :NOOVERSUBSCRIBE`)**
    Do not oversubscribe any nodes; error (without starting any
    processes) if the requested number of processes would cause
    oversubscription. This option implicitly sets "max_slots" equal
    to the "slots" value for each node. (Enabled by default).

`--npernode <#pernode>`

:   **(Deprecated: Use `--map-by ppr:<#pernode>:node`)**
    On each node, launch this many processes.

`--npersocket <#persocket>`

:   **(Deprecated: Use `--map-by ppr:<#perpackage>:package`)**
    On each node, launch this many processes times the number of
    processor sockets on the node. The `--npersocket` option also turns
    on the `--bind-to socket` option. The term `socket` has been globally
    replaced with `package`.

`--oversubscribe`

:   **(Deprecated: Use `--map-by :OVERSUBSCRIBE`)**
    Nodes are allowed to be oversubscribed, even on a managed system,
    and overloading of processing elements.

`--pernode`

:   **(Deprecated: Use `--map-by ppr:1:node`)**
    On each node, launch one process.

`--ppr`

:   **(Deprecated: Use `--map-by ppr:<list>`)**
    Comma-separated list of number of processes on a given resource type
    [default: none].

`--rankfile <FILENAME>`

:   **(Deprecated: Use `--map-by rankfile:FILE=<FILENAME>`)**
    Use a rankfile for mapping/ranking/binding

`--report-bindings`

:   **(Deprecated: Use `--display BINDINGS`)**
    Report any bindings for launched processes.

`--tag-output`

:   **(Deprecated: Use `--output TAG`)**
    Tag all output with [job,rank]

`--timestamp-output`

:   **(Deprecated: Use `--output TIMESTAMP`)**
    Timestamp all application process output

`--use-hwthread-cpus`

:   **(Deprecated: Use `--map-by :HWTCPUS`)**
    Use hardware threads as independent cpus.

`--xml`

:   **(Deprecated: Use `--output XML`)**
    Provide all output in XML format
#
#  ALL
#
[placement-all]
#include#help-prte-rmaps-base#placement

#include#help-prte-rmaps-base#placement-examples

#include#help-prte-rmaps-base#placement-fundamentals

#include#help-prte-rmaps-base#placement-limits

#include#help-prte-rmaps-base#placement-diagnostics

#include#help-prte-rmaps-base#placement-rankfiles
