.\" Automatically generated by Pandoc 2.14.2
.\"
.TH "prte-map" "1" "" "2021-08-23" "PRRTE"
.hy
.SH NAME
.PP
PRTE: Mapping, Ranking, and Binding
.SH SYNOPSIS
.PP
PRTE employs a three-phase procedure for assigning process locations and
ranks:
.IP "1." 3
\f[B]mapping\f[R]: Assigns a default location to each process
.IP "2." 3
\f[B]ranking\f[R]: Assigns a unique rank value to each process
.IP "3." 3
\f[B]binding\f[R]: Constrains each process to run on specific processors
.PP
This document describes these three phases with examples.
Unless otherwise noted, this behavior is shared by \f[C]prun\f[R],
\f[C]prterun\f[R], and \f[C]prte\f[R].
.SH QUICK SUMMARY
.PP
The two binaries that most influence process layout are \f[C]prte\f[R]
and \f[C]prun\f[R].
The \f[C]prte\f[R] process discovers the allocation, starts the daemons,
and defines the default mapping/ranking/binding for all jobs.
The \f[C]prun\f[R] process defines the specific mapping/ranking/binding
for a specific job.
Most of the command line controls are targeted to \f[C]prun\f[R] since
each job has its own unique requirements.
.PP
\f[C]prterun\f[R] is just a wrapper around \f[C]prte\f[R] for a single
job PRTE DVM.
It is doing the job of both \f[C]prte\f[R] and \f[C]prun\f[R], and, as
such, accepts the sum all of their command line arguments.
Any example that uses \f[C]prun\f[R] can substitute the use of
\f[C]prterun\f[R] except where otherwise noted.
.PP
The \f[C]prte\f[R] process attempts to automatically discover the nodes
in the allocation by querying supported resource managers.
If a support resource manager is not present then \f[C]prte\f[R] relies
on a hostfile provided by the user.
In the absence of such a hostfile it will run all processes on the
localhost.
.PP
If running under a supported resource manager, the \f[C]prte\f[R]
process will start the daemon processes (\f[C]prted\f[R]) on the remote
nodes using the corresponding resource manager process starter.
If no such starter is available then \f[C]rsh\f[R] or \f[C]ssh\f[R] is
used.
.PP
PRTE automatically maps processes in a round-robin fashion by CPU slot
in one of two ways in the absence of any further directives:
.TP
\f[B]\f[CB]Map by core:\f[B]\f[R]
when the number of total processes in the job is <= 2
.TP
\f[B]\f[CB]Map by package:\f[B]\f[R]
when the number of total processes in the job is > 2
.PP
PRTE automatically binds processes.
Three binding patterns are used in the absence of any further
directives:
.TP
\f[B]\f[CB]Bind to core:\f[B]\f[R]
when the number of total processes in the job is <= 2
.TP
\f[B]\f[CB]Bind to package:\f[B]\f[R]
when the number of total processes in the job is > 2
.TP
\f[B]\f[CB]Bind to none:\f[B]\f[R]
when oversubscribed
.PP
If your application uses threads, then you probably want to ensure that
you are either not bound at all (by specifying
\f[C]--bind-to none\f[R]), or bound to multiple cores using an
appropriate binding level or specific number of processing elements per
application process.
.PP
PRTE automatically ranks processes starting from 0.
Two ranking patterns are used in the absence of any further directives:
.TP
\f[B]\f[CB]Rank by slot:\f[B]\f[R]
when the number of total processes in the job is <= 2
.TP
\f[B]\f[CB]Rank by package:\f[B]\f[R]
when the number of total processes in the job is > 2
.SH OPTIONS
.PP
Listed here are the subset of command line options that will be used in
the process mapping/ranking/binding discussion in this manual page.
.SS Specifying Host Nodes
.PP
Use one of the following options to specify which hosts (nodes) within
the PRTE DVM environment to run on.
.TP
\f[B]\f[CB]--host <host1,host2,...,hostN>\f[B]\f[R] or \f[B]\f[CB]--host <host1:X,host2:Y,...,hostN:Z>\f[B]\f[R]
List of hosts on which to invoke processes.
After each hostname a colon (\f[C]:\f[R]) followed by a positive integer
can be used to specify the number of slots on that host (\f[C]:X\f[R],
\f[C]:Y\f[R], and \f[C]:Z\f[R]).
The default is \f[C]1\f[R].
.TP
\f[B]\f[CB]--hostfile <hostfile>\f[B]\f[R]
Provide a hostfile to use.
.TP
\f[B]\f[CB]--machinefile <machinefile>\f[B]\f[R]
Synonym for \f[C]-hostfile\f[R].
.TP
\f[B]\f[CB]--default-hostfile <hostfile>\f[B]\f[R]
Provide a default hostfile to use.
.SS Process Mapping / Ranking / Binding Options
.PP
The following options specify the number of processes to launch.
Note that none of the options imply a particular binding policy - e.g.,
requesting \f[C]N\f[R] processes for each socket does not imply that the
processes will be bound to the socket.
.TP
\f[B]\f[CB]-c, -n, --n, --np <#>\f[B]\f[R]
Run this many copies of the program on the given nodes.
This option indicates that the specified file is an executable program
and not an application context.
If no value is provided for the number of copies to execute (i.e.,
neither the \f[C]-np\f[R] nor its synonyms are provided on the command
line), \f[C]prun\f[R] will automatically execute a copy of the program
on each process slot (see below for description of a \[lq]process
slot\[rq]).
This feature, however, can only be used in the SPMD model and will
return an error (without beginning execution of the application)
otherwise.
.PP
To map processes across sets of objects:
.TP
\f[B]\f[CB]--map-by <object>\f[B]\f[R]
Map to the specified object.
See defaults in Quick Summary.
Supported options include \f[C]slot\f[R], \f[C]hwthread\f[R],
\f[C]core\f[R], \f[C]l1cache\f[R], \f[C]l2cache\f[R], \f[C]l3cache\f[R],
\f[C]package\f[R], \f[C]node\f[R], \f[C]seq\f[R], \f[C]dist\f[R],
\f[C]ppr\f[R], and \f[C]rankfile\f[R].
.PP
Any object can include qualifier by adding a colon (\f[C]:\f[R]) and any
combination of one or more of the following to the \f[C]--map-by\f[R]
option:
.IP \[bu] 2
\f[C]PE=n\f[R] bind \f[C]n\f[R] processing elements to each process
.IP \[bu] 2
\f[C]SPAN\f[R] load balance the processes across the allocation
.IP \[bu] 2
\f[C]OVERSUBSCRIBE\f[R] allow more processes on a node than processing
elements
.IP \[bu] 2
\f[C]NOOVERSUBSCRIBE\f[R] means \f[C]!OVERSUBSCRIBE\f[R]
.IP \[bu] 2
\f[C]NOLOCAL\f[R] do not launch processes on the same node as
\f[C]prun\f[R]
.IP \[bu] 2
\f[C]HWTCPUS\f[R] use hardware threads as CPU slots
.IP \[bu] 2
\f[C]CORECPUS\f[R] use cores as CPU slots (default)
.IP \[bu] 2
\f[C]DEVICE=dev\f[R] device specifier for the \f[C]dist\f[R] policy
.IP \[bu] 2
\f[C]INHERIT\f[R]
.IP \[bu] 2
\f[C]NOINHERIT\f[R] means \f[C]!INHERIT\f[R]
.IP \[bu] 2
\f[C]PE-LIST=a,b\f[R] comma-delimited ranges of cpus to use for this job
processed as an unordered pool of CPUs
.IP \[bu] 2
\f[C]FILE=%s\f[R] (path to file containing sequential or rankfile
entries).
.PP
\f[C]ppr\f[R] policy example: \f[C]--map-by ppr:N:<object>\f[R] will
launch \f[C]N\f[R] times the number of objects of the specified type on
each node.
.PP
To order processes\[cq] ranks:
.TP
\f[B]\f[CB]--rank-by <object>\f[B]\f[R]
Rank in round-robin fashion according to the specified object.
See defaults in Quick Summary.
Supported options include \f[C]slot\f[R], \f[C]hwthread\f[R],
\f[C]core\f[R], \f[C]l1cache\f[R], \f[C]l2cache\f[R], \f[C]l3cache\f[R],
\f[C]package\f[R], and \f[C]node\f[R].
.PP
Any object can include qualifiers by adding a colon (\f[C]:\f[R]) and
any combination of one or more of the following to the
\f[C]--rank-by\f[R] option:
.IP \[bu] 2
\f[C]SPAN\f[R]
.IP \[bu] 2
\f[C]FILL\f[R]
.PP
To bind processes to sets of objects:
.TP
\f[B]\f[CB]--bind-to <object>\f[B]\f[R]
Bind processes to the specified object.
See defaults in Quick Summary.
Supported options include \f[C]none\f[R], \f[C]hwthread\f[R],
\f[C]core\f[R], \f[C]l1cache\f[R], \f[C]l2cache\f[R], \f[C]l3cache\f[R],
and \f[C]package\f[R].
.PP
Any object can include qualifiers by adding a colon (\f[C]:\f[R]) and
any combination of one or more of the following to the
\f[C]--bind-to\f[R] option:
.IP \[bu] 2
\f[C]overload-allowed\f[R] allows for binding more than one process in
relation to a CPU
.IP \[bu] 2
\f[C]if-supported\f[R] if that object is supported on this system
.SS Diagnostics
.TP
\f[B]\f[CB]--map-by :DISPLAY\f[B]\f[R]
Display a table showing the mapped location of each process prior to
launch.
.TP
\f[B]\f[CB]--map-by :DISPLAYALLOC\f[B]\f[R]
Display the detected allocation of resources (e.g., nodes, slots)
.TP
\f[B]\f[CB]--bind-to :REPORT\f[B]\f[R]
Report bindings for launched processes to \f[C]stderr\f[R].
.SH DESCRIPTION
.PP
PRTE employs a three-phase procedure for assigning process locations and
ranks:
.IP "1." 3
\f[B]mapping\f[R]: Assigns a default location to each process
.IP "2." 3
\f[B]ranking\f[R]: Assigns a unique rank value to each process
.IP "3." 3
\f[B]binding\f[R]: Constrains each process to run on specific processors
.PP
The first phase of \f[B]mapping\f[R] is used to assign a default
location to each process based on the mapper being employed.
Mapping by slot, node, and sequentially results in the assignment of the
processes to the node level.
In contrast, mapping by object, allows the mapper to assign the process
to an actual object on each node.
.PP
\f[I]Note:\f[R] The location assigned to the process is independent of
where it will be bound - the assignment is used solely as input to the
binding algorithm.
.PP
The second phase focuses on the \f[B]ranking\f[R] of the process within
the job\[cq]s namespace.
PRTE separates this from the mapping procedure to allow more flexibility
in the relative placement of processes.
.PP
The third phase of \f[B]binding\f[R] actually binds each process to a
given set of processors.
This can improve performance if the operating system is placing
processes sub-optimally.
For example, it might oversubscribe some multi-core processor sockets,
leaving other sockets idle; this can lead processes to contend
unnecessarily for common resources.
Or, it might spread processes out too widely; this can be suboptimal if
application performance is sensitive to interprocess communication
costs.
Binding can also keep the operating system from migrating processes
excessively, regardless of how optimally those processes were placed to
begin with.
.PP
PRTE\[cq]s support for process binding depends on the underlying
operating system.
Therefore, certain process binding options may not be available on every
system.
.SS Specifying Host Nodes
.PP
Host nodes can be identified on the command line with the
\f[C]--host\f[R] option or in a hostfile.
.PP
For example, assuming no other resource manager or scheduler is
involved,
.TP
\f[B]\f[CB]prte --host aa,aa,bb ./a.out\f[B]\f[R]
launches two processes on node \f[C]aa\f[R] and one on \f[C]bb\f[R].
.TP
\f[B]\f[CB]prun --host aa ./a.out\f[B]\f[R]
launches one process on node \f[C]aa\f[R].
.TP
\f[B]\f[CB]prun --host aa:5 ./a.out\f[B]\f[R]
launches five processes on node \f[C]aa\f[R].
.PP
Or, consider the hostfile
.IP
.nf
\f[C]
$ cat myhostfile
aa slots=2
bb slots=2
cc slots=2
\f[R]
.fi
.PP
Here, we list both the host names (\f[C]aa\f[R], \f[C]bb\f[R], and
\f[C]cc\f[R]) but also how many \[lq]slots\[rq] there are for each.
Slots indicate how many processes can potentially execute on a node.
For best performance, the number of slots may be chosen to be the number
of cores on the node or the number of processor sockets.
.PP
If the hostfile does not provide slots information, the PRTE DVM will
attempt to discover the number of cores (or hwthreads, if the
\f[C]:HWTCPUS\f[R] qualifier to the \f[C]--map-by\f[R] option is set)
and set the number of slots to that value.
.PP
Examples using the hostfile above with and without the \f[C]--host\f[R]
option
.TP
\f[B]\f[CB]prun --hostfile myhostfile ./a.out\f[B]\f[R]
will launch two processes on each of the three nodes.
.TP
\f[B]\f[CB]prun --hostfile myhostfile --host aa ./a.out\f[B]\f[R]
will launch two processes, both on node \f[C]aa\f[R].
.TP
\f[B]\f[CB]prun --hostfile myhostfile --host dd ./a.out\f[B]\f[R]
will find no hosts to run on and abort with an error.
That is, the specified host \f[C]dd\f[R] is not in the specified
hostfile.
.PP
When running under resource managers (e.g., SLURM, Torque, etc.), PRTE
will obtain both the hostnames and the number of slots directly from the
resource manger.
The behavior of \f[C]--host\f[R] in that environment will behave the
same as if a hostfile was provided (since it is provided by the resource
manager).
.SS Specifying Number of Processes
.PP
As we have just seen, the number of processes to run can be set using
the hostfile.
Other mechanisms exist.
.PP
The number of processes launched can be specified as a multiple of the
number of nodes or processor sockets available.
Consider the hostfile below for the examples that follow.
.IP
.nf
\f[C]
$ cat myhostfile
aa
bb
\f[R]
.fi
.PP
For example,
.TP
\f[B]\f[CB]prun --hostfile myhostfile --map-by ppr:2:package ./a.out\f[B]\f[R]
launches processes 0-3 on node \f[C]aa\f[R] and process 4-7 on node
\f[C]bb\f[R], where \f[C]aa\f[R] and \f[C]bb\f[R] are both dual-package
nodes.
The \f[C]--map-by ppr:2:package\f[R] option also turns on the
\f[C]--bind-to package\f[R] option, which is discussed in a later
section.
.TP
\f[B]\f[CB]prun --hostfile myhostfile --map-by ppr:2:node ./a.out\f[B]\f[R]
launches processes 0-1 on node \f[C]aa\f[R] and processes 2-3 on node
\f[C]bb\f[R].
.TP
\f[B]\f[CB]prun --hostfile myhostfile --map-by ppr:1:node ./a.out\f[B]\f[R]
launches one process per host node.
.PP
Another alternative is to specify the number of processes with the
\f[C]--np\f[R] option.
Consider now the hostfile
.IP
.nf
\f[C]
$ cat myhostfile
aa slots=4
bb slots=4
cc slots=4
\f[R]
.fi
.PP
Now,
.TP
\f[B]\f[CB]prun --hostfile myhostfile --np 6 ./a.out\f[B]\f[R]
will launch processes 0-3 on node \f[C]aa\f[R] and processes 4-5 on node
\f[C]bb\f[R].
The remaining slots in the hostfile will not be used since the
\f[C]-np\f[R] option indicated that only 6 processes should be launched.
.SS Mapping Processes to Nodes: Using Policies
.PP
The examples above illustrate the default mapping of process processes
to nodes.
This mapping can also be controlled with various
\f[C]prun\f[R]/\f[C]prterun\f[R] options that describe mapping policies.
.IP
.nf
\f[C]
$ cat myhostfile
aa slots=4
bb slots=4
cc slots=4
\f[R]
.fi
.PP
Consider the hostfile above, with \f[C]--np 6\f[R]:
.IP
.nf
\f[C]
                              node aa      node bb      node cc
prun                          0 1 2 3      4 5
prun --map-by node            0 1          2 3          4 5
prun --map-by node:NOLOCAL                 0 1 2        3 4 5
\f[R]
.fi
.PP
The \f[C]--map-by node\f[R] option will load balance the processes
across the available nodes, numbering each process in a round-robin
fashion.
.PP
The \f[C]:NOLOCAL\f[R] qualifier to \f[C]--map-by\f[R] prevents any
processes from being mapped onto the local host (in this case node
\f[C]aa\f[R]).
While \f[C]prun\f[R] typically consumes few system resources, the
\f[C]:NOLOCAL\f[R] qualifier can be helpful for launching very large
jobs where \f[C]prun\f[R] may actually need to use noticeable amounts of
memory and/or processing time.
.PP
Just as \f[C]--np\f[R] can specify fewer processes than there are slots,
it can also oversubscribe the slots.
For example, with the same hostfile:
.TP
\f[B]\f[CB]prun --hostfile myhostfile --np 14 ./a.out\f[B]\f[R]
will produce an error since the default \f[C]:NOOVERSUBSCRIBE\f[R]
qualifier to \f[C]--map-by\f[R] prevents oversubscription.
.PP
To oversubscribe the nodes you can use the \f[C]:OVERSUBSCRIBE\f[R]
qualifier to \f[C]--map-by\f[R]:
.TP
\f[B]\f[CB]prun --hostfile myhostfile --np 14 --map-by :OVERSUBSCRIBE ./a.out\f[B]\f[R]
will launch processes 0-5 on node \f[C]aa\f[R], 6-9 on \f[C]bb\f[R], and
10-13 on \f[C]cc\f[R].
.PP
Limits to oversubscription can also be specified in the hostfile itself
with the \f[C]max_slots\f[R] field:
.IP
.nf
\f[C]
% cat myhostfile
aa slots=4 max_slots=4
bb         max_slots=8
cc slots=4
\f[R]
.fi
.PP
The \f[C]max_slots\f[R] field specifies such a limit.
When it does, the \f[C]slots\f[R] value defaults to the limit.
Now:
.TP
\f[B]\f[CB]prun --hostfile myhostfile --np 14 --map-by :OVERSUBSCRIBE ./a.out\f[B]\f[R]
causes the first 12 processes to be launched as before, but the
remaining two processes will be forced onto node cc.
The other two nodes are protected by the hostfile against
oversubscription by this job.
.PP
Using the \f[C]:NOOVERSUBSCRIBE\f[R] qualifier to \f[C]--map-by\f[R]
option can be helpful since the PRTE DVM currently does not get
\[lq]max_slots\[rq] values from the resource manager.
.PP
Of course, \f[C]--np\f[R] can also be used with the \f[C]--host\f[R]
option.
For example,
.TP
\f[B]\f[CB]prun --host aa,bb --np 8 ./a.out\f[B]\f[R]
will produce an error since the default \f[C]:NOOVERSUBSCRIBE\f[R]
qualifier to \f[C]--map-by\f[R] prevents oversubscription.
.TP
\f[B]\f[CB]prun --host aa,bb --np 8 --map-by :OVERSUBSCRIBE ./a.out\f[B]\f[R]
launches 8 processes.
Since only two hosts are specified, after the first two processes are
mapped, one to \f[C]aa\f[R] and one to \f[C]bb\f[R], the remaining
processes oversubscribe the specified hosts evenly.
.TP
\f[B]\f[CB]prun --host aa:2,bb:6 --np 8 ./a.out\f[B]\f[R]
launches 8 processes.
Processes 0-1 on node \f[C]aa\f[R] since it has 2 slots and processes
2-7 on node \f[C]bb\f[R] since it has 6 slots.
.PP
And here is a MIMD example:
.TP
\f[B]\f[CB]prun --host aa --np 1 hostname : --host bb,cc --np 2 uptime\f[B]\f[R]
will launch process 0 running \f[C]hostname\f[R] on node \f[C]aa\f[R]
and processes 1 and 2 each running \f[C]uptime\f[R] on nodes
\f[C]bb\f[R] and \f[C]cc\f[R], respectively.
.SS Mapping, Ranking, and Binding: Fundamentals
.PP
The mapping of process processes to nodes can be defined not just with
general policies but also, if necessary, using arbitrary mappings that
cannot be described by a simple policy.
One can use the \[lq]sequential mapper,\[rq] which reads the hostfile
line by line, assigning processes to nodes in whatever order the
hostfile specifies.
Use the \f[C]--prtemca rmaps seq\f[R] option.
.PP
For example, using the hostfile below:
.IP
.nf
\f[C]
% cat myhostfile
aa slots=4
bb slots=4
cc slots=4
\f[R]
.fi
.PP
The command below will launch three processes, one on each of nodes
\f[C]aa\f[R], \f[C]bb\f[R], and \f[C]cc\f[R], respectively.
The slot counts don\[cq]t matter; one process is launched per line on
whatever node is listed on the line.
.IP
.nf
\f[C]
% prun --hostfile myhostfile --prtemca rmaps seq ./a.out
\f[R]
.fi
.PP
The \f[I]ranking\f[R] phase is best illustrated by considering the
following hostfile and test cases we used the
\f[C]--map-by ppr:2:package\f[R] option:
.IP
.nf
\f[C]
% cat myhostfile
aa
bb
\f[R]
.fi
.IP
.nf
\f[C]
                         node aa       node bb
--rank-by core           0 1 ! 2 3     4 5 ! 6 7
--rank-by package        0 2 ! 1 3     4 6 ! 5 7
--rank-by package:SPAN   0 4 ! 1 5     2 6 ! 3 7
\f[R]
.fi
.PP
Ranking by core and by slot provide the identical result - a simple
progression of ranks across each node.
Ranking by package does a round-robin ranking within each node until all
processes have been assigned a rank, and then progresses to the next
node.
Adding the \f[C]:SPAN\f[R] qualifier to the ranking directive causes the
ranking algorithm to treat the entire allocation as a single entity -
thus, the process ranks are assigned across all sockets before circling
back around to the beginning.
.PP
The \f[I]binding\f[R] phase restricts the process to a subset of the CPU
resources on the node.
.PP
The processors to be used for binding can be identified in terms of
topological groupings - e.g., binding to an l3cache will bind each
process to all processors within the scope of a single L3 cache within
their assigned location.
Thus, if a process is assigned by the mapper to a certain package, then
a \f[C]--bind-to l3cache\f[R] directive will cause the process to be
bound to the processors that share a single L3 cache within that
package.
.PP
To help balance loads, the binding directive uses a round-robin method
when binding to levels lower than used in the mapper.
For example, consider the case where a job is mapped to the package
level, and then bound to core.
Each package will have multiple cores, so if multiple processes are
mapped to a given package, the binding algorithm will assign each
process located to a package to a unique core in a round-robin manner.
.PP
Alternatively, processes mapped by l2cache and then bound to package
will simply be bound to all the processors in the package where they are
located.
In this manner, users can exert detailed control over relative process
location and binding.
.PP
Process mapping/ranking/binding can also be set with MCA parameters.
Their usage is less convenient than that of the command line options.
On the other hand, MCA parameters can be set not only on the
\f[C]prun\f[R] command line, but alternatively in a system or user
\f[C]mca-params.conf\f[R] file or as environment variables, as described
in the MCA section below.
Some examples include:
.IP
.nf
\f[C]
prun option          MCA parameter key           value
--map-by core        rmaps_base_mapping_policy   core
--map-by package     rmaps_base_mapping_policy   package
--rank-by core       rmaps_base_ranking_policy   core
--bind-to core       hwloc_base_binding_policy   core
--bind-to package    hwloc_base_binding_policy   package
--bind-to none       hwloc_base_binding_policy   none
\f[R]
.fi
.SS Difference between overloading and oversubscription
.PP
This section explores the difference between these two options.
Users are often confused by the difference between these two scenarios.
As such this section provides a number of scenarios to help illustrate
the differences.
.IP \[bu] 2
\f[C]--map-by :OVERSUBSCRIBE\f[R] allow more processes on a node than
processing elements
.IP \[bu] 2
\f[C]--bind-to <object>:overload-allowed\f[R] allows for binding more
than one process in relation to a CPU
.PP
The important thing to remember with \f[I]oversubscribing\f[R] is that
it can be defined separately from the actual number of CPUs on a node.
This allows the mapper to place more or fewer processes per node than
CPUs.
By default, PRTE uses cores to determine slots in the absence of such
information provided in the hostfile or by the resource manager (except
in the case of the \f[C]--host\f[R] as described in the \[lq]Specifying
Host Nodes\[rq] section).
.PP
The important thing to remember with \f[I]overloading\f[R] is that it is
defined as binding more processes than CPUs.
By default, PRTE uses cores as a means of counting the number of CPUs.
However, the user can adjust this.
For example when using the \f[C]:HWTCPUS\f[R] qualifier to the
\f[C]--map-by\f[R] option PRTE will use hardware threads as a means of
counting the number of CPUs.
.PP
For the following examples consider a node with: - Two processor
packages, - Ten cores per package, and - Eight hardware threads per
core.
.PP
Consider the node from above with the hostfile below:
.IP
.nf
\f[C]
$ cat myhostfile
node01 slots=32
node02 slots=32
\f[R]
.fi
.PP
The \[lq]slots\[rq] tells PRTE that it can place up to 32 processes
before \f[I]oversubscribing\f[R] the node.
.PP
If we run the following:
.IP
.nf
\f[C]
prun --np 34 --hostfile myhostfile --map-by core --bind-to core hostname
\f[R]
.fi
.PP
It will return an error at the binding time indicating an
\f[I]overloading\f[R] scenario.
.PP
The mapping mechanism assigns 32 processes to \f[C]node01\f[R] matching
the \[lq]slots\[rq] specification in the hostfile.
The binding mechanism will bind the first 20 processes to unique cores
leaving it with 12 processes that it cannot bind without overloading one
of the cores (putting more than one process on the core).
.PP
Using the \f[C]overload-allowed\f[R] qualifier to the
\f[C]--bind-to core\f[R] option tells PRTE that it may assign more than
one process to a core.
.PP
If we run the following:
.IP
.nf
\f[C]
prun --np 34 --hostfile myhostfile --map-by core --bind-to core:overload-allowed hostname
\f[R]
.fi
.PP
This will run correctly placing 32 processes on \f[C]node01\f[R], and 2
processes on \f[C]node02\f[R].
On \f[C]node01\f[R] two processes are bound to cores 0-11 accounting for
the overloading of those cores.
.PP
Alternatively, we could use hardware threads to give binding a lower
level CPU to bind to without overloading.
.PP
If we run the following:
.IP
.nf
\f[C]
prun --np 34 --hostfile myhostfile --map-by core:HWTCPUS --bind-to hwthread hostname
\f[R]
.fi
.PP
This will run correctly placing 32 processes on \f[C]node01\f[R], and 2
processes on \f[C]node02\f[R].
On \f[C]node01\f[R] two processes are mapped to cores 0-11 but bound to
different hardware threads on those cores (the logical first and second
hardware thread) thus no hardware threads are overloaded at binding
time.
.PP
In both of the examples above the node is not oversubscribed at mapping
time because the hostfile set the oversubscription limit to
\[lq]slots=32\[rq] for each node.
It is only after we exceed that limit that PRTE will throw an
oversubscription error.
.PP
Consider next if we ran the following:
.IP
.nf
\f[C]
prun --np 66 --hostfile myhostfile --map-by core:HWTCPUS --bind-to hwthread hostname
\f[R]
.fi
.PP
This will return an error at mapping time indicating an oversubscription
scenario.
The mapping mechanism will assign all of the available slots (64 across
2 nodes) and be left two processes to map.
The only way to map those processes is to exceed the number of available
slots putting the job into an oversubscription scenario.
.PP
You can force PRTE to oversubscribe the nodes by using the
\f[C]:OVERSUBSCRIBE\f[R] qualifier to the \f[C]--map-by\f[R] option as
seen in the example below:
.IP
.nf
\f[C]
prun --np 66 --hostfile myhostfile --map-by core:HWTCPUS:OVERSUBSCRIBE --bind-to hwthread hostname
\f[R]
.fi
.PP
This will run correctly placing 34 processes on \f[C]node01\f[R] and 32
on \f[C]node02\f[R].
Each process is bound to a unique hardware thread.
.SS Overloading vs Oversubscription: Package Example
.PP
Let\[cq]s extend these examples by considering the package level.
Consider the same node as before, but with the hostfile below:
.IP
.nf
\f[C]
$ cat myhostfile
node01 slots=22
node02 slots=22
\f[R]
.fi
.PP
The lowest level CPUs are `cores' and we have 20 total (10 per package).
.PP
If we run:
.IP
.nf
\f[C]
prun --np 20 --hostfile myhostfile --map-by package --bind-to package:REPORT hostname
\f[R]
.fi
.PP
Then 10 processes are mapped to each package, and bound at the package
level.
This is not overloading since we have 10 CPUs (cores) available in the
package at the hardware level.
.PP
However, if we run:
.IP
.nf
\f[C]
prun --np 21 --hostfile myhostfile --map-by package --bind-to package:REPORT hostname
\f[R]
.fi
.PP
Then 11 processes are mapped to the first package and 10 to the second
package.
At binding time we have an overloading scenario because there are only
10 CPUs (cores) available in the package at the hardware level.
So the first package is overloaded.
.SS Overloading vs Oversubscription: Hardware Threads Example
.PP
Similarly, if we consider hardware threads.
.PP
Consider the same node as before, but with the hostfile below:
.IP
.nf
\f[C]
$ cat myhostfile
node01 slots=165
node02 slots=165
\f[R]
.fi
.PP
The lowest level CPUs are `hwthreads' (because we are going to use the
\f[C]:HWTCPUS\f[R] qualifier) and we have 160 total (80 per package).
.PP
If we re-run (from the package example) and add the \f[C]:HWTCPUS\f[R]
qualifier:
.IP
.nf
\f[C]
prun --np 21 --hostfile myhostfile --map-by package:HWTCPUS --bind-to package:REPORT hostname
\f[R]
.fi
.PP
Without the \f[C]:HWTCPUS\f[R] qualifier this would be overloading (as
we saw previously).
The mapper places 11 processes on the first package and 10 to the second
package.
The processes are still bound to the package level.
However, with the \f[C]:HWTCPUS\f[R] qualifier, it is not overloading
since we have 80 CPUs (hwthreads) available in the package at the
hardware level.
.PP
Alternatively, if we run:
.IP
.nf
\f[C]
prun --np 161 --hostfile myhostfile --map-by package:HWTCPUS --bind-to package:REPORT hostname
\f[R]
.fi
.PP
Then 81 processes are mapped to the first package and 80 to the second
package.
At binding time we have an overloading scenario because there are only
80 CPUs (hwthreads) available in the package at the hardware level.
So the first package is overloaded.
.SS Diagnostics
.PP
PRTE provides various diagnostic reports that aid the user in verifying
and tuning the mapping/ranking/binding for a specific job.
.PP
The \f[C]:REPORT\f[R] qualifier to \f[C]--bind-to\f[R] command line
option can be used to report process bindings.
.PP
As an example, consider a node with: - Two processor packages, - Four
cores per package, and - Eight hardware threads per core.
.PP
In each of the examples below the binding is reported in a human
readable format.
.IP
.nf
\f[C]
$ prun --np 4 --map-by core --bind-to core:REPORT ./a.out
[node01:103137] MCW rank 0 bound to package[0][core:0]
[node01:103137] MCW rank 1 bound to package[0][core:1]
[node01:103137] MCW rank 2 bound to package[0][core:2]
[node01:103137] MCW rank 3 bound to package[0][core:3]
\f[R]
.fi
.PP
The example above processes bind to successive cores on the first
package.
.IP
.nf
\f[C]
$ prun --np 4 --map-by package --bind-to package:REPORT ./a.out
[node01:103115] MCW rank 0 bound to package[0][core:0-9]
[node01:103115] MCW rank 1 bound to package[1][core:10-19]
[node01:103115] MCW rank 2 bound to package[0][core:0-9]
[node01:103115] MCW rank 3 bound to package[1][core:10-19]
\f[R]
.fi
.PP
The example above processes bind to all cores on successive packages.
The processes cycle though the packages in a round-robin fashion as many
times as are needed.
.IP
.nf
\f[C]
$ prun --np 4 --map-by package:PE=2 --bind-to core:REPORT ./a.out
[node01:103328] MCW rank 0 bound to package[0][core:0-1]
[node01:103328] MCW rank 1 bound to package[1][core:10-11]
[node01:103328] MCW rank 2 bound to package[0][core:2-3]
[node01:103328] MCW rank 3 bound to package[1][core:12-13]
\f[R]
.fi
.PP
The example above shows us that 2 cores have been bound per process.
The \f[C]:PE=2\f[R] qualifier states that 2 processing elements
underneath the package (which would be cores in this case) are mapped to
each process.
The processes cycle though the packages in a round-robin fashion as many
times as are needed.
.IP
.nf
\f[C]
$ prun --np 4 --map-by core:PE=2:HWTCPUS --bind-to :REPORT  hostname
[node01:103506] MCW rank 0 bound to package[0][hwt:0-1]
[node01:103506] MCW rank 1 bound to package[0][hwt:8-9]
[node01:103506] MCW rank 2 bound to package[0][hwt:16-17]
[node01:103506] MCW rank 3 bound to package[0][hwt:24-25]
\f[R]
.fi
.PP
The example above shows us that 2 hardware threads have been bound per
process.
In this case \f[C]prun\f[R] is mapping by hardware threads since we used
the \f[C]:HWTCPUS\f[R] qualifier.
Without that qualifier this command would return an error since by
default \f[C]prun\f[R] will not map to resources smaller than a core.
The \f[C]:PE=2\f[R] qualifier states that 2 processing elements
underneath the core (which would be hardware threads in this case) are
mapped to each process.
The processes cycle though the cores in a round-robin fashion as many
times as are needed.
.IP
.nf
\f[C]
$ prun --np 4 --bind-to none:REPORT  hostname
[node01:107126] MCW rank 0 is not bound (or bound to all available processors)
[node01:107126] MCW rank 1 is not bound (or bound to all available processors)
[node01:107126] MCW rank 2 is not bound (or bound to all available processors)
[node01:107126] MCW rank 3 is not bound (or bound to all available processors)
\f[R]
.fi
.PP
The example above binding is turned off.
.SS Rankfiles
.PP
Another way to specify arbitrary mappings is with a rankfile, which
gives you detailed control over process binding as well.
.PP
Rankfiles are text files that specify detailed information about how
individual processes should be mapped to nodes, and to which
processor(s) they should be bound.
Each line of a rankfile specifies the location of one process.
The general form of each line in the rankfile is:
.IP
.nf
\f[C]
rank <N>=<hostname> slot=<slot list>
\f[R]
.fi
.PP
For example:
.IP
.nf
\f[C]
$ cat myrankfile
rank 0=c712f6n01 slot=10-12
rank 1=c712f6n02 slot=0,1,4
rank 2=c712f6n03 slot=1-2
$ prun --host aa,bb,cc,dd --map-by rankfile:FILE=myrankfile ./a.out
\f[R]
.fi
.PP
Means that
.IP
.nf
\f[C]
Rank 0 runs on node aa, bound to logical cores 10-12.
Rank 1 runs on node bb, bound to logical cores 0, 1, and 4.
Rank 2 runs on node cc, bound to logical cores 1 and 2.
\f[R]
.fi
.PP
For example:
.IP
.nf
\f[C]
$ cat myrankfile
rank 0=aa slot=1:0-2
rank 1=bb slot=0:0,1,4
rank 2=cc slot=1-2
$ prun --host aa,bb,cc,dd --map-by rankfile:FILE=myrankfile ./a.out
\f[R]
.fi
.PP
Means that
.IP
.nf
\f[C]
Rank 0 runs on node aa, bound to logical package 1, cores 10-12 (the 0th through 2nd cores on that package).
Rank 1 runs on node bb, bound to logical package 0, cores 0, 1, and 4.
Rank 2 runs on node cc, bound to logical cores 1 and 2.
\f[R]
.fi
.PP
The hostnames listed above are \[lq]absolute,\[rq] meaning that actual
resolvable hostnames are specified.
However, hostnames can also be specified as \[lq]relative,\[rq] meaning
that they are specified in relation to an externally-specified list of
hostnames (e.g., by \f[C]prun\f[R]\[cq]s \f[C]--host\f[R] argument, a
hostfile, or a job scheduler).
.PP
The \[lq]relative\[rq] specification is of the form
\[lq]\f[C]+n<X>\f[R]\[rq], where \f[C]X\f[R] is an integer specifying
the Xth hostname in the set of all available hostnames, indexed from 0.
For example:
.IP
.nf
\f[C]
$ cat myrankfile
rank 0=+n0 slot=10-12
rank 1=+n1 slot=0,1,4
rank 2=+n2 slot=1-2
$ prun --host aa,bb,cc,dd --map-by rankfile:FILE=myrankfile ./a.out
\f[R]
.fi
.PP
All package/core slot locations are be specified as \f[I]logical\f[R]
indexes.
You can use tools such as HWLOC\[cq]s \[lq]lstopo\[rq] to find the
logical indexes of packages and cores.
.SS Deprecated Options
.PP
These deprecated options will be removed in a future release.
.TP
\f[B]\f[CB]--bind-to-core\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--bind-to core\f[B])\f[R] Bind processes to
cores
.TP
\f[B]\f[CB]-bind-to-socket, --bind-to-socket\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--bind-to package\f[B])\f[R] Bind processes
to processor sockets
.TP
\f[B]\f[CB]--bycore\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by core\f[B])\f[R] Map processes by
core
.TP
\f[B]\f[CB]-bynode, --bynode\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by node\f[B])\f[R] Launch processes
one per node, cycling by node in a round-robin fashion.
This spreads processes evenly among nodes and assigns ranks in a
round-robin, \[lq]by node\[rq] manner.
.TP
\f[B]\f[CB]--byslot\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by slot\f[B])\f[R] Map and rank
processes round-robin by slot.
.TP
\f[B]\f[CB]--cpus-per-proc <#perproc>\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by <obj>:PE=<#perproc>\f[B])\f[R] Bind
each process to the specified number of cpus.
.TP
\f[B]\f[CB]--cpus-per-rank <#perrank>\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by <obj>:PE=<#perrank>\f[B])\f[R]
Alias for \f[C]--cpus-per-proc\f[R].
.TP
\f[B]\f[CB]--display-allocation\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by :DISPLAYALLOC\f[B])\f[R] Display
the detected resource allocation.
.TP
\f[B]\f[CB]--display-devel-map\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by :DISPLAYDEVEL\f[B])\f[R] Display a
detailed process map (mostly intended for developers) just before
launch.
.TP
\f[B]\f[CB]--display-map\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by :DISPLAY\f[B])\f[R] Display a table
showing the mapped location of each process prior to launch.
.TP
\f[B]\f[CB]--display-topo\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by :DISPLAYTOPO\f[B])\f[R] Display the
topology as part of the process map (mostly intended for developers)
just before launch.
.TP
\f[B]\f[CB]--do-not-launch\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by :DONOTLAUNCH\f[B])\f[R] Perform all
necessary operations to prepare to launch the application, but do not
actually launch it (usually used to test mapping patterns).
.TP
\f[B]\f[CB]--do-not-resolve\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by :DONOTRESOLVE\f[B])\f[R] Do not
attempt to resolve interfaces - usually used to determine proposed
process placement/binding prior to obtaining an allocation.
.TP
\f[B]\f[CB]-N <num>\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by prr:<num>:node\f[B])\f[R] Launch
\f[C]num\f[R] processes per node on all allocated nodes.
.TP
\f[B]\f[CB]--nolocal\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by :NOLOCAL\f[B])\f[R] Do not run any
copies of the launched application on the same node as \f[C]prun\f[R] is
running.
This option will override listing the \f[C]localhost\f[R] with
\f[C]--host\f[R] or any other host-specifying mechanism.
.TP
\f[B]\f[CB]--nooversubscribe\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by :NOOVERSUBSCRIBE\f[B])\f[R] Do not
oversubscribe any nodes; error (without starting any processes) if the
requested number of processes would cause oversubscription.
This option implicitly sets \[lq]max_slots\[rq] equal to the
\[lq]slots\[rq] value for each node.
(Enabled by default).
.TP
\f[B]\f[CB]--npernode <#pernode>\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by ppr:<#pernode>:node\f[B])\f[R] On
each node, launch this many processes.
.TP
\f[B]\f[CB]--npersocket <#persocket>\f[B]\f[R]
\f[B](Deprecated: Use
\f[CB]--map-by ppr:<#perpackage>:package\f[B])\f[R] On each node, launch
this many processes times the number of processor sockets on the node.
The \f[C]--npersocket\f[R] option also turns on the
\f[C]--bind-to socket\f[R] option.
The term \f[C]socket\f[R] has been globally replaced with
\f[C]package\f[R].
.TP
\f[B]\f[CB]--oversubscribe\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by :OVERSUBSCRIBE\f[B])\f[R] Nodes are
allowed to be oversubscribed, even on a managed system, and overloading
of processing elements.
.TP
\f[B]\f[CB]--pernode\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by ppr:1:node\f[B])\f[R] On each node,
launch one process.
.TP
\f[B]\f[CB]--ppr\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by ppr:<list>\f[B])\f[R]
Comma-separated list of number of processes on a given resource type
[default: none].
.TP
\f[B]\f[CB]--rankfile <FILENAME>\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by rankfile:FILE=<FILENAME>\f[B])\f[R]
Use a rankfile for mapping/ranking/binding
.TP
\f[B]\f[CB]--report-bindings\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--bind-to :REPORT\f[B])\f[R] Report any
bindings for launched processes.
.TP
\f[B]\f[CB]--tag-output\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by :TAGOUTPUT\f[B])\f[R] Tag all
output with [job,rank]
.TP
\f[B]\f[CB]--timestamp-output\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by :TIMESTAMPOUTPUT\f[B])\f[R]
Timestamp all application process output
.TP
\f[B]\f[CB]--use-hwthread-cpus\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by :HWTCPUS\f[B])\f[R] Use hardware
threads as independent cpus.
.TP
\f[B]\f[CB]--xml\f[B]\f[R]
\f[B](Deprecated: Use \f[CB]--map-by :XMLOUTPUT\f[B])\f[R] Provide all
output in XML format
